---
title: "R Notebook"
output: html_notebook
---

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

Note that the survival curve S(t) = P(T> t) is right-continuous (same as cdf). 

```{r}
library(dplyr)
library(icenReg)

simulate_data_dep <- function(n, k, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  
  # --- Simulate covariates ---
  # 'race' is a categorical variable with 3 levels (represented as 1, 2, or 3)
  race <- sample(1:3, n, replace = TRUE, prob = rep(1/3, 3))
  # Simulate the numerical variable (values 1,2,3)
  X_num <- sample(1:3, n, replace = TRUE, prob = rep(1/3, 3))
  
  # Compute a categorical effect based on race:
  # For example:
  # - Race 1: effect = 0
  # - Race 2: effect = 0.5
  # - Race 3: effect = -0.5
  cat_effect <- ifelse(race == 1, 0, ifelse(race == 2, 0.5, -0.5))
  
  # --- Define possible values for Delta and T ---
  delta_vals <- 1:k   # Delta takes values from -4 to 4 (9 categories)
  T_vals     <- 1:k    # T takes values from 1 to 5 (5 categories)
  
  # Pre-allocate vectors for Delta and T.
  Delta <- numeric(n)
  T <- numeric(n)
  
  
  # --- Sample Delta and T conditionally on the covariates ---
  for (i in 1:n) {
    # For Delta:
    weights_delta <- rep(1/k, k)
    Delta[i] <- sample(delta_vals, 1, prob = weights_delta)
    
    # For T:
    #weights_T <- exp(T_vals / 2 + 0.3 * X_num[i] + cat_effect[i])
    weights_T <- rep(1/k, k)
    T[i] <- sample(T_vals, 1, prob = weights_T)
  }
  
  # --- Compute the indicator variable ---
  Indicator <- as.integer(Delta >= T) #indicator whether patient feel significantly improved 
  
  # --- Combine into a data frame ---
  # 'race' remains as a numeric variable.
  df <- data.frame(
    Delta = Delta,
    T = T,
    Indicator = Indicator,
    race = race,
    X_num = X_num
  )
  
  df$L <- ifelse(df$Indicator == 1, 1, df$Delta) #double-check
  df$R <- ifelse(df$Indicator == 1, df$Delta, k) #double-check
  
  return(df)
}


compute_mean_time_ic_np <- function(model, which_row = 1) {
  model <- getSCurves(model)  

  # Extract Turnbull intervals (a k x 2 matrix)
  Tbull_ints <- model$Tbull_ints
  
  # Extract survival curve estimates
  S_curve <- model$S_curves[[1]] #double-check
  # If S_curve is a matrix (multiple covariate profiles), select one row
  if (is.matrix(S_curve)) {
    S_curve <- S_curve[which_row, ]
  }
  
  k <- length(S_curve)
  
  # Compute probability masses from the survival drops:
  # p1 = 1 - S_curve[1]
  # p_j = S_curve[j-1] - S_curve[j] for j >= 2
  p <- numeric(k)
  p[1] <- 1 - S_curve[1]
  if (k > 1) {
    p[2:k] <- S_curve[1:(k - 1)] - S_curve[2:k]
  }
  
  # Compute representative times: use the midpoint of each Turnbull interval
  midpoints <- rowMeans(Tbull_ints)
  
  # Calculate the mean event time as the weighted average of the midpoints
  mean_event_time <- sum(p * midpoints)
  
  return(mean_event_time)
}

```

#Meta function
```{r}
MIC <- function(df, method, user_formula = NULL, cov_input = NULL) {
  
  if(method == "np"){
    
    model <- ic_np(cbind(df$l, df$r))
    
    p1 <- nrow(df %>% filter(Delta ==1, Indicator == 1)) / nrow(df %>% filter(Delta ==1))
    s <- getSCurves(fit_np)$S_curves[[1]]
    s[2] = 1 - p1
    meanT <- compute_mean_time_ic_np(model)
    
    meanD <- mean()
    
  }else if(method == "po"){
    
    full_formula <- as.formula(
      paste("Surv(L, R, type = 'interval2') ~", user_formula) #formula is user specified, e.g. "X_num + factor(race)"
      )
    
    model <- ic_sp(full_formula, data = df, model = "po")
    
  }else if(method == "ph"){
    
    full_formula <- as.formula(
      paste("Surv(L, R, type = 'interval2') ~", user_formula) #formula is user specified, e.g. "X_num + factor(race)"
    )
    
    model <- ic_sp(full_formula, data = df, model = "ph")
    
  }else{
    stop("Unsupported method: ", method)
  }
  
  result <- list(
    model = model,
    mean = mean_value
  )
  
  return(result)
}
```



#Data simulation 
```{r}
data <- simulate_data_dep(10000, 3, seed = 22)
df <- subset(data, select = -T) #dataframe without T
print(data)
```



```{r}
#sp stands for semi-parametric
fit_np <- ic_np(cbind(df$l, df$r))
fit_po <- ic_sp(Surv(L, R, type = "interval2") ~ X_num + factor(race), data = df, model = "po") #The covariates does matter 
fit_ph <- ic_sp(Surv(L, R, type = "interval2") ~ X_num + factor(race), data = df, model = "ph") 

#compute_mean_time_ic_np(np_curve)
plot(fit_np)
plot(fit_po)
plot(fit_ph)

#compute E[T]
compute_mean_time_ic_np(fit_np)
compute_mean_time_ic_np(fit_po)
compute_mean_time_ic_np(fit_ph)
```


```{r}
s <- getSCurves(fit_ph)$Tbull_ints
print(s)


# Create a new data frame with the covariate values you want to examine.
newcov <- data.frame(race =1, X_num = 2)
# Use predict with type = "surv" to get the survival probabilities over time.
s_ph <- getSCurves(fit_ph, newcov)
s_ph
```

#Exploiting the discreteness 
```{r}

p1 <- nrow(df %>% filter(Delta ==1, Indicator == 1)) / nrow(df %>% filter(Delta ==1))
s <- getSCurves(fit_np)$S_curves[[1]]
s[2] = 1 - p1
s

#Throw away data with delta == 1? So the missing mechanism is independent from the outcome
#df_minus_1 <- df %>% filter(Delta !=1)
#fit_np_new <- ic_np(cbind(df_minus_1$l, df_minus_1$r))
#plot(fit_np_new)

#s_new <- getSCurves(fit_np_new)
#s_new$S_curves
```


```

