---
title: "R Notebook"
output: html_notebook
---

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

Note that the survival curve S(t) = P(T> t) is right-continuous (same as cdf). 

```{r}

library(icenReg)

simulate_data_dep <- function(n, k, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  
  # --- Simulate covariates ---
  # 'race' is a categorical variable with 3 levels (represented as 1, 2, or 3)
  race <- sample(1:3, n, replace = TRUE, prob = rep(1/3, 3))
  # Simulate the numerical variable (values 1,2,3)
  X_num <- sample(1:3, n, replace = TRUE, prob = rep(1/3, 3))
  
  # Compute a categorical effect based on race:
  # For example:
  # - Race 1: effect = 0
  # - Race 2: effect = 0.5
  # - Race 3: effect = -0.5
  cat_effect <- ifelse(race == 1, 0, ifelse(race == 2, 0.5, -0.5))
  
  # --- Define possible values for Delta and T ---
  delta_vals <- 1:k   # Delta takes values from -4 to 4 (9 categories)
  T_vals     <- 1:k    # T takes values from 1 to 5 (5 categories)
  
  # Pre-allocate vectors for Delta and T.
  Delta <- numeric(n)
  T <- numeric(n)
  
  
  # --- Sample Delta and T conditionally on the covariates ---
  for (i in 1:n) {
    # For Delta:
    weights_delta <- rep(1/k, k)
    Delta[i] <- sample(delta_vals, 1, prob = weights_delta)
    
    # For T:
    #weights_T <- exp(T_vals / 2 + 0.3 * X_num[i] + cat_effect[i])
    weights_T <- rep(1/k, k)
    T[i] <- sample(T_vals, 1, prob = weights_T)
  }
  
  # --- Compute the indicator variable ---
  Indicator <- as.integer(Delta >= T) #indicator whether patient feel significantly improved 
  
  # --- Combine into a data frame ---
  # 'race' remains as a numeric variable.
  df <- data.frame(
    Delta = Delta,
    T = T,
    Indicator = Indicator,
    race = race,
    X_num = X_num
  )
  
  df$l <- ifelse(df$Indicator == 1, 1, df$Delta) #double-check
  df$r <- ifelse(df$Indicator == 1, df$Delta, k) #double-check
  
  return(df)
}



compute_mean_time_ic_np <- function(model, which_row = 1) {
  model <- getSCurves(model)  

  # Extract Turnbull intervals (a k x 2 matrix)
  Tbull_ints <- model$Tbull_ints
  
  # Extract survival curve estimates
  S_curve <- model$S_curves[[1]] #double-check
  # If S_curve is a matrix (multiple covariate profiles), select one row
  if (is.matrix(S_curve)) {
    S_curve <- S_curve[which_row, ]
  }
  
  k <- length(S_curve)
  
  # Compute probability masses from the survival drops:
  # p1 = 1 - S_curve[1]
  # p_j = S_curve[j-1] - S_curve[j] for j >= 2
  p <- numeric(k)
  p[1] <- 1 - S_curve[1]
  if (k > 1) {
    p[2:k] <- S_curve[1:(k - 1)] - S_curve[2:k]
  }
  
  # Compute representative times: use the midpoint of each Turnbull interval
  midpoints <- rowMeans(Tbull_ints)
  
  # Calculate the mean event time as the weighted average of the midpoints
  mean_event_time <- sum(p * midpoints)
  
  return(mean_event_time)
}

```


```{r}
# Example usage:
data <- simulate_data_dep(10000, 2, seed = 32)
df <- subset(data, select = -T) #dataframe without T
print(data)
```

#Simulate the 

```{r}
#sp stands for semi-parametric
fit_np <- ic_np(cbind(df$l, df$r))
fit_po <- ic_sp(Surv(l, r, type = "interval2") ~ X_num + factor(race), data = df, model = "po") #The covariates does matter 
fit_ph <- ic_sp(Surv(l, r, type = "interval2") ~ X_num + factor(race), data = df, model = "ph") 


#compute_mean_time_ic_np(np_curve)
plot(fit_np)
plot(fit_po)
plot(fit_ph)
```
```{r}
compute_mean_time_ic_np(fit_np)
compute_mean_time_ic_np(fit_po)
compute_mean_time_ic_np(fit_ph)
```

```{r}
s <- getSCurves(fit_ph)$Tbull_ints
print(s)
```
